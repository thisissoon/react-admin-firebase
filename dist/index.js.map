{"version":3,"file":"index.js","sources":["../src/misc/timestamp-parser.ts","../src/misc/document-parser.ts","../src/misc/arrayHelpers.ts","../src/misc/objectFlatten.ts","../src/misc/logger/logger-base.ts","../src/misc/logger/logger.ts","../src/misc/logger/firestore-logger.ts","../src/misc/file-parser.ts","../src/misc/pathHelper.ts","../src/providers/database/firebase/FirebaseWrapper.ts","../src/providers/database/ResourceManager.ts","../src/providers/database/FireClient.ts","../src/misc/metadata-parser.ts","../src/providers/lazy-loading/queryCursors.ts","../src/providers/lazy-loading/paramsToQuery.ts","../src/providers/lazy-loading/FirebaseLazyLoadingClient.ts","../src/providers/AuthProvider.ts","../src/misc/status-code-translator.ts","../src/providers/DataProvider.ts","../src/providers/queries/GetList.ts","../src/providers/queries/GetOne.ts","../src/providers/queries/GetMany.ts","../src/providers/queries/GetManyReference.ts","../src/providers/commands/Update.ts","../src/providers/commands/UpdateMany.ts","../src/providers/commands/Create.ts","../src/providers/commands/Delete.ts","../src/providers/commands/Delete.Soft.ts","../src/providers/commands/DeleteMany.ts","../src/providers/commands/DeleteMany.Soft.ts"],"sourcesContent":["export function parseAllDatesDoc(obj: any) {\n  const isObject = !!obj && typeof obj === 'object';\n  if (!isObject) {\n    return;\n  }\n  Object.keys(obj).map(key => {\n    const value = obj[key];\n    obj[key] = recusivelyCheckObjectValue(value);\n  });\n}\n\nexport function recusivelyCheckObjectValue(input: any): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map(value => recusivelyCheckObjectValue(value));\n  }\n  const isObject = typeof input === 'object';\n  if (isObject) {\n    Object.keys(input).map(key => {\n      const value = input[key];\n      input[key] = recusivelyCheckObjectValue(value);\n    });\n    return input;\n  }\n}\n","import { QueryDocumentSnapshot } from '@firebase/firestore-types';\nimport { parseAllDatesDoc } from './timestamp-parser';\n\nexport const parseFireStoreDocument = (doc: QueryDocumentSnapshot) => {\n  const data = doc.data();\n  parseAllDatesDoc(data);\n  // React Admin requires an id field on every document,\n  // So we can just using the firestore document id\n  return { id: doc.id, ...data };\n};\n","import { get, isEmpty } from 'lodash';\nimport { getFieldReferences, SearchObj } from './objectFlatten';\n\nexport function sortArray(\n  data: Array<{}>,\n  field: string,\n  dir: 'asc' | 'desc'\n): void {\n  data.sort((a: {}, b: {}) => {\n    const rawA = get(a, field);\n    const rawB = get(b, field);\n    const isAsc = dir === \"asc\";\n\n    const isNumberField = Number.isFinite(rawA) && Number.isFinite(rawB);\n    if (isNumberField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    const isStringField = typeof rawA === 'string' && typeof rawB === 'string';\n    if (isStringField) {\n      const aParsed = rawA.toLowerCase();\n      const bParsed = rawB.toLowerCase();\n      return basicSort(aParsed, bParsed, isAsc);\n    }\n    const isDateField = rawA instanceof Date && rawB instanceof Date;\n    if (isDateField) {\n      return basicSort(rawA, rawB, isAsc);\n    }\n    return basicSort(!!rawA, !!rawB, isAsc);\n  });\n}\n\nfunction basicSort(aValue: any, bValue: any, isAsc: boolean) {\n  if (aValue > bValue) {\n    return isAsc ? 1 : -1;\n  }\n  if (aValue < bValue) {\n    return isAsc ? -1 : 1;\n  }\n  return 0;\n}\n\nexport function filterArray(\n  data: Array<{}>,\n  searchFields?: { [field: string]: string | number | boolean | null }\n): Array<{}> {\n  if (!searchFields || isEmpty(searchFields)) {\n    return data;\n  }\n  const searchObjs: SearchObj[] = [];\n  Object.keys(searchFields).map((fieldName) => {\n    const fieldValue = searchFields[fieldName];\n    const getSubObjects = getFieldReferences(fieldName, fieldValue);\n    searchObjs.push(...getSubObjects);\n  });\n  const filtered = data.filter((row) =>\n    searchObjs.reduce((acc, cur) => {\n      const res = doesRowMatch(row, cur.searchField, cur.searchValue);\n      return res && acc;\n    }, true as boolean)\n  );\n  return filtered;\n}\n\nexport function doesRowMatch(\n  row: {},\n  searchField: string,\n  searchValue: any\n): boolean {\n  const searchThis = get(row, searchField);\n  const bothAreFalsey = !searchThis && !searchValue;\n  if (bothAreFalsey) {\n    return true;\n  }\n  const nothingToSearch = !searchThis;\n  if (nothingToSearch) {\n    return false;\n  }\n  const isStringSearch = typeof searchValue === 'string';\n  if (isStringSearch) {\n    return searchThis\n      .toString()\n      .toLowerCase()\n      .includes(searchValue.toLowerCase());\n  }\n  const isBooleanOrNumber =\n    typeof searchValue === 'boolean' || typeof searchValue === 'number';\n  if (isBooleanOrNumber) {\n    return searchThis === searchValue;\n  }\n  return false;\n}\n","export interface SearchObj {\n  searchField: string;\n  searchValue: number | string | boolean | null;\n}\nexport function getFieldReferences(\n  fieldName: string,\n  value: {} | number | string | boolean | null\n): SearchObj[] {\n  const isFalsy = !value;\n  const isSimple = isFalsy ||\n    typeof value === 'string' ||\n    typeof value === 'number' ||\n    typeof value === 'boolean';\n\n  if (isSimple) {\n    return [\n      {\n        searchField: fieldName,\n        searchValue: value as number | string | boolean | null,\n      },\n    ];\n  }\n  const tree = {} as any;\n  tree[fieldName] = value;\n  return objectFlatten(tree);\n}\n\nexport function objectFlatten(tree: {}): SearchObj[] {\n  var leaves: SearchObj[] = [];\n  var recursivelyWalk = function (obj: any, path: string | null) {\n    path = path || \"\";\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        const objVal = obj && obj[key];\n        const currentPath = !!path ? path + \".\" + key : key;\n        const isWalkable =\n          typeof objVal === 'object' || objVal instanceof Array;\n        if (isWalkable) {\n          recursivelyWalk(objVal, currentPath);\n        } else {\n          leaves.push({ searchField: currentPath, searchValue: objVal });\n        }\n      }\n    }\n  };\n  recursivelyWalk(tree, null);\n  return leaves;\n}\n","type LogFn = (...args: any) => void;\n\nexport const LogNoOp: LogFn = (...args: any) => null;\n\nexport class LoggerBase {\n  constructor(private title: string, private cacheEnabledKey: string) {}\n\n  private isEnabled() {\n    return !!localStorage.getItem(this.cacheEnabledKey);\n  }\n\n  SetEnabled(isEnabled: boolean) {\n    if (isEnabled) {\n      localStorage.setItem(this.cacheEnabledKey, 'true');\n    } else {\n      localStorage.removeItem(this.cacheEnabledKey);\n    }\n  }\n\n  public get log() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.log.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get warn() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.warn.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n\n  public get error() {\n    if (!this.isEnabled()) {\n      return LogNoOp;\n    }\n    const boundLogFn: (...args: any) => void = console.error.bind(\n      console,\n      this.title\n    );\n    return boundLogFn;\n  }\n}\n","import { LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_ENABLED';\nexport const logger = new LoggerBase('ðŸ”¥raf:', LOGGER_ENABLEDKEY);\n\nexport const log = logger.log;\nexport const logError = logger.error;\nexport const logWarn = logger.warn;\n","import { RAFirebaseOptions } from 'providers/options';\nimport { LogNoOp, LoggerBase } from './logger-base';\n\nconst LOGGER_ENABLEDKEY = 'LOGGING_FIRESTORE_COSTS_ENABLED';\nconst logger = new LoggerBase('ðŸ’¸firestore-costs:', LOGGER_ENABLEDKEY);\n\nconst KEY_SINGLE = 'firecosts-single-reads';\n\nexport interface IFirestoreLogger {\n  logDocument: (count: number) => Function;\n  SetEnabled: (isEnabled: boolean) => void;\n  ResetCount: (shouldReset: boolean) => void;\n}\n\nexport function MakeFirestoreLogger(\n  options: RAFirebaseOptions\n): IFirestoreLogger {\n  function notEnabled() {\n    return !options?.lazyLoading?.enabled;\n  }\n\n  function incrementRead(incrementBy = 1) {\n    const currentCountRaw = localStorage.getItem(KEY_SINGLE) || '';\n    const currentCount = parseInt(currentCountRaw) || 0;\n    const incremented = currentCount + incrementBy;\n    localStorage.setItem(KEY_SINGLE, incremented + '');\n    return incremented;\n  }\n  function clearCache() {\n    localStorage.removeItem(KEY_SINGLE);\n  }\n  return {\n    SetEnabled(isEnabled: boolean) {\n      logger.SetEnabled(isEnabled);\n    },\n    ResetCount(shouldReset: boolean) {\n      shouldReset && clearCache()\n    },\n    logDocument(docCount: number) {\n      if (notEnabled()) {\n        return LogNoOp;\n      }\n      const count = incrementRead(docCount);\n      const suffix = `+${docCount} (session total=${count} documents read)`;\n      const boundLogFn: (...args: any) => void = logger.log.bind(\n        console,\n        suffix\n      );\n      return boundLogFn;\n    },\n  };\n}\n","import { logError } from './logger';\nimport { IFirebaseWrapper } from '../providers/database/firebase/IFirebaseWrapper';\n\ninterface ParsedUpload {\n  fieldDotsPath: string;\n  fieldSlashesPath: string;\n  rawFile: File | any;\n}\n\nexport function parseDocGetAllUploads(obj: any): ParsedUpload[] {\n  const isObject = !!obj && typeof obj === \"object\";\n  if (!isObject) {\n    return [];\n  }\n  const uploads: ParsedUpload[] = [];\n  Object.keys(obj).map((key) => {\n    const value = obj[key];\n    recusivelyParseObjectValue(value, key, uploads);\n  });\n  return uploads;\n}\n\nexport function recusivelyParseObjectValue(\n  input: any,\n  fieldPath: string,\n  uploads: ParsedUpload[]\n): any {\n  const isFalsey = !input;\n  if (isFalsey) {\n    return input;\n  }\n  const isPrimitive = typeof input !== 'object';\n  if (isPrimitive) {\n    return input;\n  }\n  const isTimestamp = !!input.toDate && typeof input.toDate === 'function';\n  if (isTimestamp) {\n    return input.toDate();\n  }\n  const isArray = Array.isArray(input);\n  if (isArray) {\n    return (input as []).map((value, index) =>\n      recusivelyParseObjectValue(value, `${fieldPath}.${index}`, uploads)\n    );\n  }\n  const isObject = typeof input === 'object';\n  if (!isObject) {\n    return;\n  }\n  const isFileField = !!input && input.hasOwnProperty('rawFile');\n  if (isFileField) {\n    uploads.push({\n      fieldDotsPath: fieldPath,\n      fieldSlashesPath: fieldPath.split('.').join('/'),\n      rawFile: input.rawFile\n    });\n    delete input.rawFile;\n    return;\n  }\n  Object.keys(input).map((key) => {\n    const value = input[key];\n    recusivelyParseObjectValue(value, `${fieldPath}.${key}`, uploads);\n  });\n  return input;\n}\n\nexport const recursivelyMapStorageUrls = async (\n  fireWrapper: IFirebaseWrapper,\n  fieldValue: any\n): Promise<any> => {\n  const isArray = Array.isArray(fieldValue);\n  const isObject = !isArray && typeof fieldValue === \"object\";\n  const isFileField = isObject && !!fieldValue && fieldValue.hasOwnProperty(\"src\");\n  if (isFileField) {\n    const isAlreadyUploaded = fieldValue.src.startsWith('https://');\n    if (isAlreadyUploaded) {\n      return fieldValue;\n    }\n    let ref: firebase.storage.Reference = null as any;\n    try {\n      ref = fireWrapper.storage().ref(fieldValue.src);\n      const src = await ref.getDownloadURL();\n      return {\n        ...fieldValue,\n        src\n      };\n    } catch (error) {\n      logError(`Error when getting download URL`, {\n        error,\n        fieldValue,\n        ref\n      });\n      return fieldValue;\n    }\n  } else if (isObject) {\n    for (let key in fieldValue) {\n      if (fieldValue.hasOwnProperty(key)) {\n        const value = fieldValue[key];\n        fieldValue[key] = await recursivelyMapStorageUrls(fireWrapper, value);\n      }\n    }\n\n    return fieldValue;\n  } else if (isArray) {\n    for (let i = 0; i < fieldValue.length; i++) {\n      fieldValue[i] = await recursivelyMapStorageUrls(fireWrapper, fieldValue[i])\n    }\n\n    return fieldValue;\n  }\n\n  return fieldValue;\n};\n","import path from \"path-browserify\";\n\nexport function getAbsolutePath(\n  rootRef: undefined | string | (() => string),\n  relativePath: string | null\n): string {\n  if (!rootRef) {\n    return relativePath+'';\n  }\n  if (!relativePath) {\n    throw new Error(\n      \"Resource name must be a string of length greater than 0 characters\"\n    );\n  }\n  const rootRefValue = typeof rootRef === \"string\" ? rootRef : rootRef();\n  const withSlashes = path.join(\"/\", rootRefValue, \"/\", relativePath, \"/\");\n  const slashCount = withSlashes.split(\"/\").length - 1;\n  if (slashCount % 2) {\n    throw new Error(`The rootRef path must point to a \"document\"\n    not a \"collection\"e.g. /collection/document/ or\n    /collection/document/collection/document/`);\n  }\n  return withSlashes.slice(1, -1);\n}\n\nexport function joinPaths(...args: string[]) {\n  return path.join(...args);\n}\n","import { FireApp, IFirebaseWrapper } from './IFirebaseWrapper';\n\nimport firebase, { User } from 'firebase/app';\nimport 'firebase/firestore';\nimport 'firebase/auth';\nimport 'firebase/storage';\nimport { log } from 'misc';\nimport { RAFirebaseOptions } from 'providers/options';\n\nexport class FirebaseWrapper implements IFirebaseWrapper {\n  private firestore: firebase.firestore.Firestore = null as any;\n  private app: FireApp = null as any;\n  public options: RAFirebaseOptions = {};\n\n  public GetApp(): FireApp {\n    return this.app;\n  }\n\n  constructor() {}\n\n  public init(firebaseConfig: {}, options?: RAFirebaseOptions): void {\n    const optionsSafe = options || {};\n    this.options = optionsSafe;\n    this.app = ObtainFirebaseApp(firebaseConfig, optionsSafe);\n    this.firestore = this.app.firestore();\n  }\n  public db(): firebase.firestore.Firestore {\n    return this.firestore;\n  }\n  public serverTimestamp() {\n    // This line doesn't work for some reason, might be firebase sdk.\n    // return firebase.firestore.FieldValue.serverTimestamp();\n    return new Date();\n  }\n  public auth() {\n    return this.app.auth() as any;\n  }\n  public storage() {\n    return this.app.storage();\n  }\n  public async GetUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      this.app.auth().onAuthStateChanged((user) => {\n        if (user) {\n          resolve(user);\n        } else {\n          reject('getUserLogin() no user logged in');\n        }\n      });\n    });\n  }\n  public OnUserLogout(callBack: (u: firebase.User | null) => any) {\n    this.app.auth().onAuthStateChanged((user) => {\n      const isLoggedOut = !user;\n      log('FirebaseWrapper.OnUserLogout', { user, isLoggedOut });\n      if (isLoggedOut) {\n        callBack(user);\n      }\n    });\n  }\n}\n\nfunction ObtainFirebaseApp(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): firebase.app.App {\n  if (options.app) {\n    return options.app;\n  }\n  const isInitialized = !!firebase.apps.length;\n  if (isInitialized) {\n    return firebase.app();\n  } else {\n    return firebase.initializeApp(firebaseConfig);\n  }\n}\n","// Firebase types\nimport {\n  CollectionReference,\n  QueryDocumentSnapshot,\n  FirebaseFirestore,\n} from '@firebase/firestore-types';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\nimport {\n  log,\n  getAbsolutePath,\n  messageTypes,\n  parseAllDatesDoc,\n  logWarn,\n  IFirestoreLogger,\n} from '../../misc';\n\nexport interface IResource {\n  path: string;\n  pathAbsolute: string;\n  collection: CollectionReference;\n  list: Array<{} & { deleted?: boolean }>;\n}\n\nexport class ResourceManager {\n  private resources: {\n    [resourceName: string]: IResource;\n  } = {};\n\n  private db: FirebaseFirestore;\n\n  constructor(\n    private fireWrapper: IFirebaseWrapper,\n    private options: RAFirebaseOptions,\n    private flogger: IFirestoreLogger\n  ) {\n    this.db = fireWrapper.db();\n\n    this.fireWrapper.OnUserLogout(() => {\n      this.resources = {};\n    });\n  }\n\n  public async TryGetResource(\n    resourceName: string,\n    refresh?: 'REFRESH',\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    if (refresh) {\n      await this.RefreshResource(resourceName, collectionQuery);\n    }\n    return this.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n\n  public GetResource(relativePath: string): IResource {\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Can't find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async TryGetResourcePromise(\n    relativePath: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    log('resourceManager.TryGetResourcePromise', {\n      relativePath,\n      collectionQuery,\n    });\n    await this.initPath(relativePath);\n\n    const resource: IResource = this.resources[relativePath];\n    if (!resource) {\n      throw new Error(\n        `react-admin-firebase: Cant find resource: \"${relativePath}\"`\n      );\n    }\n    return resource;\n  }\n\n  public async RefreshResource(\n    relativePath: string,\n    collectionQuery: messageTypes.CollectionQueryType | undefined\n  ) {\n    if (this.options?.lazyLoading?.enabled) {\n      logWarn('resourceManager.RefreshResource', {\n        warn: 'RefreshResource is not available in lazy loading mode',\n      });\n      throw new Error(\n        'react-admin-firebase: RefreshResource is not available in lazy loading mode'\n      );\n    }\n\n    log('resourceManager.RefreshResource', { relativePath, collectionQuery });\n    await this.initPath(relativePath);\n    const resource = this.resources[relativePath];\n\n    const collection = resource.collection;\n    const query = this.applyQuery(collection, collectionQuery);\n    const newDocs = await query.get();\n\n    resource.list = newDocs.docs.map((doc) => this.parseFireStoreDocument(doc));\n    const count = newDocs.docs.length;\n    this.flogger.logDocument(count)();\n    log('resourceManager.RefreshResource', {\n      newDocs,\n      resource,\n      collectionPath: collection.path,\n    });\n  }\n\n  public async GetSingleDoc(relativePath: string, docId: string) {\n    await this.initPath(relativePath);\n    const resource = this.GetResource(relativePath);\n    this.flogger.logDocument(1)();\n    const docSnap = await resource.collection.doc(docId).get();\n    if (!docSnap.exists) {\n      throw new Error('react-admin-firebase: No id found matching: ' + docId);\n    }\n    const result = this.parseFireStoreDocument(docSnap as any);\n    log('resourceManager.GetSingleDoc', {\n      relativePath,\n      resource,\n      docId,\n      docSnap,\n      result,\n    });\n    return result;\n  }\n\n  private async initPath(relativePath: string): Promise<void> {\n    const rootRef = this.options && this.options.rootRef;\n    const absolutePath = getAbsolutePath(rootRef, relativePath);\n    const hasBeenInited = !!this.resources[relativePath];\n    log('resourceManager.initPath()', {\n      absolutePath,\n      hasBeenInited,\n    });\n    if (hasBeenInited) {\n      log('resourceManager.initPath() has been initialized already...');\n      return;\n    }\n    const collection = this.db.collection(absolutePath);\n    const list: Array<{}> = [];\n    const resource: IResource = {\n      collection,\n      list,\n      path: relativePath,\n      pathAbsolute: absolutePath,\n    };\n    this.resources[relativePath] = resource;\n    log('resourceManager.initPath() setting resource...', {\n      resource,\n      allResources: this.resources,\n      collection: collection,\n      collectionPath: collection.path,\n    });\n  }\n\n  private parseFireStoreDocument(doc: QueryDocumentSnapshot | undefined): {} {\n    if (!doc) {\n      logWarn('parseFireStoreDocument: no doc', { doc });\n      return {};\n    }\n    const data = doc.data();\n    parseAllDatesDoc(data);\n    // React Admin requires an id field on every document,\n    // So we can just using the firestore document id\n    return { id: doc.id, ...data };\n  }\n\n  public async getUserIdentifier(): Promise<string> {\n    const identifier = this.options.associateUsersById\n      ? await this.getCurrentUserId()\n      : await this.getCurrentUserEmail();\n    return identifier;\n  }\n\n  private async getCurrentUserEmail() {\n    const user = await this.fireWrapper.GetUserLogin();\n    if (user) {\n      return user.email as string;\n    } else {\n      return 'annonymous user';\n    }\n  }\n  private async getCurrentUserId() {\n    const user = await this.fireWrapper.GetUserLogin();\n    if (user) {\n      return user.uid;\n    } else {\n      return 'annonymous user';\n    }\n  }\n\n  private applyQuery(\n    collection: CollectionReference,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): CollectionReference {\n    const collRef: CollectionReference = collectionQuery\n      ? collectionQuery(collection)\n      : collection;\n\n    log('resourceManager.applyQuery() ...', {\n      collection,\n      collectionQuery: (collectionQuery || '-').toString(),\n      collRef,\n    });\n    return collRef;\n  }\n}\n","import { set } from 'lodash';\nimport {\n  AddCreatedByFields,\n  AddUpdatedByFields,\n  IFirestoreLogger,\n  joinPaths,\n  log,\n  logError,\n  parseDocGetAllUploads,\n} from '../../misc';\nimport { RAFirebaseOptions } from '../options';\nimport { IFirebaseWrapper } from './firebase/IFirebaseWrapper';\nimport { IResource, ResourceManager } from './ResourceManager';\nimport { v4 as uuidv4 } from 'uuid';\n\ninterface UploadRes {\n  id: string;\n  src: string;\n}\n\nexport class FireClient {\n  public rm: ResourceManager;\n  public db() {\n    return this.fireWrapper.db();\n  }\n\n  constructor(\n    public fireWrapper: IFirebaseWrapper,\n    public options: RAFirebaseOptions,\n    public flogger: IFirestoreLogger\n  ) {\n    this.rm = new ResourceManager(this.fireWrapper, this.options, this.flogger);\n  }\n\n  public checkRemoveIdField(obj: any, docId: string) {\n    if (!this.options.dontAddIdFieldToDoc) {\n      obj.id = docId;\n    }\n  }\n\n  public async parseDataAndUpload(r: IResource, id: string, data: any) {\n    if (!data) {\n      return data;\n    }\n    const docPath = r.collection.doc(id).path;\n\n    const uploads = parseDocGetAllUploads(data);\n    await Promise.all(\n      uploads.map(async (u) => {\n        const uploadRes = await this.uploadAndGetLink(\n          u.rawFile,\n          docPath,\n          u.fieldSlashesPath,\n          !!this.options.useFileNamesInStorage\n        );\n        set(data, u.fieldDotsPath + '.src', uploadRes?.src);\n        set(data, u.fieldDotsPath + '.id', uploadRes?.id);\n      })\n    );\n    return data;\n  }\n\n  public async addCreatedByFields(obj: any) {\n    return AddCreatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  public async addUpdatedByFields(obj: any) {\n    return AddUpdatedByFields(obj, this.fireWrapper, this.rm, this.options);\n  }\n\n  private async uploadAndGetLink(\n    rawFile: any,\n    docPath: string,\n    fieldPath: string,\n    useFileName: boolean\n  ): Promise<UploadRes | undefined> {\n    // create a storage path compatible with flite and return the image id\n    const id = uuidv4();\n    const storagePath = `${id}/${id}`;\n    console.log('storage path', storagePath);\n    const path = await this.saveFile(storagePath, rawFile);\n    return {\n      id: id,\n      src: path || '',\n    };\n  }\n\n  private async saveFile(\n    storagePath: string,\n    rawFile: any\n  ): Promise<string | undefined> {\n    log('saveFile() saving file...', { storagePath, rawFile });\n    const task = this.fireWrapper.storage().ref(storagePath).put(rawFile);\n    try {\n      const taskResult: firebase.storage.UploadTaskSnapshot = await new Promise(\n        (res, rej) => task.then(res).catch(rej)\n      );\n      const getDownloadURL = await taskResult.ref.getDownloadURL();\n      log('saveFile() saved file', {\n        storagePath,\n        taskResult,\n        getDownloadURL,\n      });\n      return this.options.relativeFilePaths ? storagePath : getDownloadURL;\n    } catch (storageError) {\n      if (storageError.code === 'storage/unknown') {\n        logError(\n          'saveFile() error saving file, No bucket found! Try clicking \"Get Started\" in firebase -> storage',\n          { storageError }\n        );\n      } else {\n        logError('saveFile() error saving file', {\n          storageError,\n        });\n      }\n    }\n  }\n}\n","import { RAFirebaseOptions } from \"index\";\nimport { IFirebaseWrapper, ResourceManager } from \"providers/database\";\n\nexport async function AddCreatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const createAtSelector = GetSelectorsCreateAt(options);\n  const createBySelector = GetSelectorsCreateBy(options);\n  obj[createAtSelector] = fireWrapper.serverTimestamp();\n  obj[createBySelector] = currentUserIdentifier;\n}\n\nexport async function AddUpdatedByFields(\n  obj: any,\n  fireWrapper: IFirebaseWrapper,\n  rm: Pick<ResourceManager, \"getUserIdentifier\">,\n  options: Pick<\n    RAFirebaseOptions,\n    | \"associateUsersById\"\n    | \"disableMeta\"\n    | \"renameMetaFields\"\n    | \"metaFieldCasing\"\n  >\n) {\n  if (options.disableMeta) {\n    return;\n  }\n  const currentUserIdentifier = await rm.getUserIdentifier();\n  const updateAtSelector = GetSelectorsUpdateAt(options);\n  const updateBySelector = GetSelectorsUpdateBy(options);\n  obj[updateAtSelector] = fireWrapper.serverTimestamp();\n  obj[updateBySelector] = currentUserIdentifier;\n}\n\nexport function GetSelectorsUpdateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_at) {\n    return options.renameMetaFields.updated_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"lastupdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"lastUpdate\";\n  }\n  if (casing === \"snake\") {\n    return \"last_update\";\n  }\n  if (casing === \"pascal\") {\n    return \"LastUpdate\";\n  }\n  if (casing === \"kebab\") {\n    return \"last-update\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsUpdateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.updated_by) {\n    return options.renameMetaFields.updated_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"updatedby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"updatedBy\";\n  }\n  if (casing === \"snake\") {\n    return \"updated_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"UpdatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"updated-by\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateAt(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_at) {\n    return options.renameMetaFields.created_at;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdate\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createDate\";\n  }\n  if (casing === \"snake\") {\n    return \"create_date\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreateDate\";\n  }\n  if (casing === \"kebab\") {\n    return \"create-date\";\n  }\n  return defautCase;\n}\n\nexport function GetSelectorsCreateBy(\n  options: Pick<RAFirebaseOptions, \"metaFieldCasing\" | \"renameMetaFields\">\n): string {\n  if (options.renameMetaFields && options.renameMetaFields.created_by) {\n    return options.renameMetaFields.created_by;\n  }\n  const casing = options.metaFieldCasing;\n  const defautCase = \"createdby\";\n  if (!casing) {\n    return defautCase;\n  }\n  if (casing === \"camel\") {\n    return \"createdBy\";\n  }\n  if (casing === \"snake\") {\n    return \"created_by\";\n  }\n  if (casing === \"pascal\") {\n    return \"CreatedBy\";\n  }\n  if (casing === \"kebab\") {\n    return \"created-by\";\n  }\n  return defautCase;\n}\n","import {\n  CollectionReference,\n  DocumentSnapshot,\n  Query,\n} from '@firebase/firestore-types';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\n\nexport function setQueryCursor(\n  doc: DocumentSnapshot,\n  params: messageTypes.IParamsGetList,\n  resourceName: string\n) {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  localStorage.setItem(key, doc.id);\n\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (!localCursorKeys) {\n    localStorage.setItem(allCursorsKey, JSON.stringify([key]));\n  } else {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    const newCursors = cursors.concat(key);\n    localStorage.setItem(allCursorsKey, JSON.stringify(newCursors));\n  }\n}\n\nexport async function getQueryCursor(\n  collection: CollectionReference,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<DocumentSnapshot | false> {\n  const key = btoa(JSON.stringify({ ...params, resourceName }));\n  const docId = localStorage.getItem(key);\n  if (!docId) {\n    return false;\n  }\n\n  const doc = await collection.doc(docId).get();\n  flogger.logDocument(1)();\n  if (doc.exists) {\n    // incrementFirebaseReadsCounter(1);\n    return doc;\n  }\n  return false;\n}\n\nexport function clearQueryCursors(resourceName: string) {\n  const allCursorsKey = `ra-firebase-cursor-keys_${resourceName}`;\n  const localCursorKeys = localStorage.getItem(allCursorsKey);\n  if (localCursorKeys) {\n    const cursors: string[] = JSON.parse(localCursorKeys);\n    cursors.forEach((cursor) => localStorage.removeItem(cursor));\n    localStorage.removeItem(allCursorsKey);\n  }\n}\n\nexport async function findLastQueryCursor(\n  collection: CollectionReference,\n  queryBase: Query,\n  params: messageTypes.IParamsGetList,\n  resourceName: string,\n  flogger: IFirestoreLogger\n) {\n  const { page, perPage } = params.pagination;\n\n  let lastQueryCursor: DocumentSnapshot | false = false;\n  let currentPage = page - 1;\n\n  const currentPageParams = {\n    ...params,\n    pagination: {\n      ...params.pagination,\n    },\n  };\n  while (!lastQueryCursor && currentPage > 1) {\n    currentPage--;\n    currentPageParams.pagination.page = currentPage;\n    console.log('getting query cursor currentPage=', currentPage);\n    lastQueryCursor = await getQueryCursor(\n      collection,\n      currentPageParams,\n      resourceName,\n      flogger\n    );\n  }\n  const limit = (page - currentPage) * perPage;\n  const isFirst = currentPage === 1;\n\n  function getQuery() {\n    if (isFirst) {\n      return queryBase.limit(limit);\n    } else {\n      return queryBase.startAt(lastQueryCursor).limit(limit);\n    }\n  }\n\n  const newQuery = getQuery();\n  const snapshots = await newQuery.get();\n  const docsLength = snapshots.docs.length;\n  flogger.logDocument(docsLength)();\n  const lastDocIndex = docsLength - 1;\n  const lastDocRef = snapshots.docs[lastDocIndex];\n  return lastDocRef;\n}\n","import {\n  CollectionReference,\n  OrderByDirection,\n  Query,\n} from '@firebase/firestore-types';\nimport { IFirestoreLogger, messageTypes } from '../../misc';\nimport { findLastQueryCursor, getQueryCursor } from './queryCursors';\n\ninterface ParamsToQueryOptions {\n  filters?: boolean;\n  sort?: boolean;\n  pagination?: boolean;\n}\n\nconst defaultParamsToQueryOptions = {\n  filters: true,\n  sort: true,\n  pagination: true,\n};\n\nexport async function paramsToQuery<\n  TParams extends messageTypes.IParamsGetList\n>(\n  collection: CollectionReference,\n  params: TParams,\n  resourceName: string,\n  flogger: IFirestoreLogger,\n  options: ParamsToQueryOptions = defaultParamsToQueryOptions\n): Promise<Query> {\n  const filtersStepQuery = options.filters\n    ? filtersToQuery(collection, params.filter)\n    : collection;\n\n  const sortStepQuery = options.sort\n    ? sortToQuery(filtersStepQuery, params.sort)\n    : filtersStepQuery;\n\n  return options.pagination\n    ? paginationToQuery(\n        sortStepQuery,\n        params,\n        collection,\n        resourceName,\n        flogger\n      )\n    : sortStepQuery;\n}\n\nexport function filtersToQuery(\n  query: Query,\n  filters: { [fieldName: string]: any }\n): Query {\n  Object.keys(filters).forEach((fieldName) => {\n    query = query.where(fieldName, '==', filters[fieldName]);\n  });\n  return query;\n}\n\nexport function sortToQuery(\n  query: Query,\n  sort: { field: string; order: string }\n): Query {\n  if (sort != null && sort.field !== 'id') {\n    const { field, order } = sort;\n    const parsedOrder = order.toLocaleLowerCase() as OrderByDirection;\n    query = query.orderBy(field, parsedOrder);\n  }\n  return query;\n}\n\nasync function paginationToQuery<TParams extends messageTypes.IParamsGetList>(\n  query: Query,\n  params: TParams,\n  collection: CollectionReference,\n  resourceName: string,\n  flogger: IFirestoreLogger\n): Promise<Query> {\n  const { page, perPage } = params.pagination;\n  if (page === 1) {\n    query = query.limit(perPage);\n  } else {\n    let queryCursor = await getQueryCursor(\n      collection,\n      params,\n      resourceName,\n      flogger\n    );\n    if (!queryCursor) {\n      queryCursor = await findLastQueryCursor(\n        collection,\n        query,\n        params,\n        resourceName,\n        flogger\n      );\n    }\n    query = query.startAfter(queryCursor).limit(perPage);\n  }\n\n  return query;\n}\n\nexport function getFullParamsForQuery<\n  TParams extends messageTypes.IParamsGetList\n>(reactAdminParams: TParams, softdeleteEnabled: boolean): TParams {\n  return {\n    ...reactAdminParams,\n    filter: softdeleteEnabled\n      ? {\n          deleted: false,\n          ...reactAdminParams.filter,\n        }\n      : reactAdminParams.filter,\n  };\n}\n\nexport function getNextPageParams<TParams extends messageTypes.IParamsGetList>(\n  params: TParams\n): TParams {\n  return {\n    ...params,\n    pagination: {\n      ...params.pagination,\n      page: params.pagination.page + 1,\n    },\n  };\n}\n","import {\n  log,\n  messageTypes,\n  parseFireStoreDocument,\n  recursivelyMapStorageUrls,\n} from '../../misc';\nimport {\n  CollectionReference,\n  DocumentSnapshot,\n} from '@firebase/firestore-types';\nimport { IResource, ResourceManager } from '../database/ResourceManager';\nimport { RAFirebaseOptions } from '../options';\nimport * as ra from '../../misc/react-admin-models';\nimport {\n  getFullParamsForQuery,\n  getNextPageParams,\n  paramsToQuery,\n} from './paramsToQuery';\nimport { clearQueryCursors, setQueryCursor } from './queryCursors';\nimport { FireClient } from 'providers/database';\n\nexport class FirebaseLazyLoadingClient {\n  constructor(\n    private readonly options: RAFirebaseOptions,\n    private readonly rm: ResourceManager,\n    private client: FireClient\n  ) {}\n\n  public async apiGetList<T extends ra.Record>(\n    resourceName: string,\n    reactAdminParams: ra.GetListParams\n  ): Promise<ra.GetListResult<T>> {\n    const r = await this.tryGetResource(resourceName);\n    const params = getFullParamsForQuery(\n      reactAdminParams,\n      !!this.options.softDelete\n    );\n\n    log('apiGetListLazy', { resourceName, params });\n\n    const query = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await query.get();\n\n    const resultsCount = snapshots.docs.length;\n    if (!resultsCount) {\n      log('apiGetListLazy', {\n        message: 'There are not records for given query',\n      });\n      return { data: [], total: 0 };\n    }\n    this.client.flogger.logDocument(resultsCount)();\n\n    const data = snapshots.docs.map(parseFireStoreDocument) as T[];\n    const nextPageCursor = snapshots.docs[snapshots.docs.length - 1];\n    // After fetching documents save queryCursor for next page\n    setQueryCursor(nextPageCursor, getNextPageParams(params), resourceName);\n    // Hardcoded to allow next pages, as we don't have total number of items\n    let total = 9000;\n\n    // Check for next pages\n    // If it's last page, we can count all items and disable going to next page\n    const isOnLastPage = await this.checkIfOnLastPage(\n      r.collection,\n      params,\n      resourceName,\n      nextPageCursor\n    );\n\n    if (isOnLastPage) {\n      const { page, perPage } = params.pagination;\n      total = (page - 1) * perPage + data.length;\n      log('apiGetListLazy', { message: \"It's last page of collection.\" });\n    }\n\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetListLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total,\n      };\n    }\n\n    log('apiGetListLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n\n    return { data, total };\n  }\n\n  public async apiGetManyReference(\n    resourceName: string,\n    reactAdminParams: messageTypes.IParamsGetManyReference\n  ): Promise<messageTypes.IResponseGetManyReference> {\n    const r = await this.tryGetResource(resourceName);\n    log('apiGetManyReferenceLazy', {\n      resourceName,\n      resource: r,\n      reactAdminParams,\n    });\n    const filterWithTarget = {\n      ...reactAdminParams.filter,\n      [reactAdminParams.target]: reactAdminParams.id,\n    };\n    const params = getFullParamsForQuery(\n      {\n        ...reactAdminParams,\n        filter: filterWithTarget,\n      },\n      !!this.options.softDelete\n    );\n\n    const query = await paramsToQuery(\n      r.collection,\n      params,\n      resourceName,\n      this.client.flogger\n    );\n\n    const snapshots = await query.get();\n    const resultsCount = snapshots.docs.length;\n    this.client.flogger.logDocument(resultsCount)();\n    const data = snapshots.docs.map(parseFireStoreDocument);\n    if (this.options.relativeFilePaths) {\n      const parsedData = await Promise.all(\n        data.map(async (doc: any) => {\n          for (let fieldName in doc) {\n            doc[fieldName] = await recursivelyMapStorageUrls(\n              this.client.fireWrapper,\n              doc[fieldName]\n            );\n          }\n          return doc;\n        })\n      );\n\n      log('apiGetManyReferenceLazy result', {\n        docs: parsedData,\n        resource: r,\n        collectionPath: r.collection.path,\n      });\n\n      return {\n        data: parsedData,\n        total: data.length,\n      };\n    }\n\n    log('apiGetManyReferenceLazy result', {\n      docs: data,\n      resource: r,\n      collectionPath: r.collection.path,\n    });\n    return { data, total: data.length };\n  }\n\n  private async checkIfOnLastPage<TParams extends messageTypes.IParamsGetList>(\n    collection: CollectionReference,\n    params: TParams,\n    resourceName: string,\n    nextPageCursor: DocumentSnapshot\n  ): Promise<boolean> {\n    const query = await paramsToQuery(\n      collection,\n      params,\n      resourceName,\n      this.client.flogger,\n      {\n        filters: true,\n        sort: true,\n      }\n    );\n    if (!nextPageCursor) {\n      throw new Error('Page cursor was empty...');\n    }\n    const nextElementSnapshot = await query\n      .startAfter(nextPageCursor)\n      .limit(1)\n      .get();\n\n    if (!nextElementSnapshot.empty) {\n      // this.incrementFirebaseReadsCounter(1);\n    }\n\n    return nextElementSnapshot.empty;\n  }\n\n  public clearQueryCursors(resourceName: string) {\n    clearQueryCursors(resourceName);\n  }\n\n  private async tryGetResource(\n    resourceName: string,\n    collectionQuery?: messageTypes.CollectionQueryType\n  ): Promise<IResource> {\n    return this.rm.TryGetResourcePromise(resourceName, collectionQuery);\n  }\n}\n","import { messageTypes } from './../misc/messageTypes';\nimport firebase from 'firebase/app';\nimport 'firebase/auth';\nimport { FirebaseAuth, User } from '@firebase/auth-types';\nimport { log, retrieveStatusTxt, logWarn, logger } from '../misc';\nimport { RAFirebaseOptions } from './options';\nimport { FirebaseWrapper } from './database/firebase/FirebaseWrapper';\nimport {\n  AuthProvider as RaAuthProvider,\n  UserIdentity,\n} from '../misc/react-admin-models';\n\nclass AuthClient {\n  private auth: FirebaseAuth;\n\n  constructor(firebaseConfig: {}, optionsInput?: RAFirebaseOptions) {\n    const options = optionsInput || {};\n    log('Auth Client: initializing...', { firebaseConfig, options });\n    const fireWrapper = new FirebaseWrapper();\n    fireWrapper.init(firebaseConfig, options);\n    this.auth = fireWrapper.auth();\n    options.persistence && this.setPersistence(options.persistence);\n  }\n\n  setPersistence(persistenceInput: 'session' | 'local' | 'none') {\n    let persistenceResolved: string;\n    switch (persistenceInput) {\n      case 'local':\n        persistenceResolved = firebase.auth.Auth.Persistence.LOCAL;\n        break;\n      case 'none':\n        persistenceResolved = firebase.auth.Auth.Persistence.NONE;\n        break;\n      case 'session':\n      default:\n        persistenceResolved = firebase.auth.Auth.Persistence.SESSION;\n        break;\n    }\n    log('setPersistence', { persistenceInput, persistenceResolved });\n    this.auth\n      .setPersistence(persistenceResolved)\n      .catch((error) => console.error(error));\n  }\n\n  public async HandleAuthLogin(params: { username: string; password: string }) {\n    const { username, password } = params;\n\n    if (username && password) {\n      try {\n        const user = await this.auth.signInWithEmailAndPassword(\n          username,\n          password\n        );\n        log('HandleAuthLogin: user sucessfully logged in', { user });\n        return user;\n      } catch (e) {\n        log('HandleAuthLogin: invalid credentials', { params });\n        throw new Error('Login error: invalid credentials');\n      }\n    } else {\n      return this.getUserLogin();\n    }\n  }\n\n  public HandleAuthLogout() {\n    return this.auth.signOut();\n  }\n\n  public HandleAuthError(errorHttp: messageTypes.HttpErrorType) {\n    log('HandleAuthLogin: invalid credentials', { errorHttp });\n    const status = !!errorHttp && errorHttp.status;\n    const statusTxt = retrieveStatusTxt(status);\n    if (statusTxt === 'ok') {\n      log('API is actually authenticated');\n      return Promise.resolve();\n    }\n    logWarn('Recieved authentication error from API');\n    return Promise.reject();\n  }\n\n  public async HandleAuthCheck(): Promise<void> {\n    return this.getUserLogin() as any; // Prevents breaking change\n  }\n\n  public getUserLogin(): Promise<User> {\n    return new Promise((resolve, reject) => {\n      if (this.auth.currentUser) return resolve(this.auth.currentUser);\n      const unsubscribe = this.auth.onAuthStateChanged((user) => {\n        unsubscribe();\n        if (user) {\n          resolve(user);\n        } else {\n          reject();\n        }\n      });\n    });\n  }\n\n  public async HandleGetPermissions() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.claims;\n    } catch (e) {\n      log('HandleGetPermission: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetIdentity(): Promise<UserIdentity> {\n    try {\n      const { uid, displayName, photoURL } = await this.getUserLogin();\n      const identity: UserIdentity = {\n        id: uid,\n        fullName: `${displayName ?? ''}`,\n        avatar: `${photoURL ?? ''}`,\n      };\n      return identity;\n    } catch (e) {\n      log('HandleGetIdentity: no user is logged in', {\n        e,\n      });\n      return null as any;\n    }\n  }\n\n  public async HandleGetJWTAuthTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.authTime;\n    } catch (e) {\n      log('HandleGetJWTAuthTime: no user is logged in or tokenResult error', {\n        e,\n      });\n      return null;\n    }\n  }\n\n  public async HandleGetJWTExpirationTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.expirationTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTExpirationTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTSignInProvider() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.signInProvider;\n    } catch (e) {\n      log(\n        'HandleGetJWTSignInProvider: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTIssuedAtTime() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.issuedAtTime;\n    } catch (e) {\n      log(\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n\n  public async HandleGetJWTToken() {\n    try {\n      const user = await this.getUserLogin();\n      // @ts-ignore\n      const token = await user.getIdTokenResult();\n\n      return token.token;\n    } catch (e) {\n      log(\n        'HandleGetJWTIssuedAtTime: no user is logged in or tokenResult error',\n        {\n          e,\n        }\n      );\n      return null;\n    }\n  }\n}\n\nexport function AuthProvider(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n): RaAuthProvider {\n  VerifyAuthProviderArgs(firebaseConfig, options);\n  logger.SetEnabled(!!options?.logging);\n  const auth = new AuthClient(firebaseConfig, options);\n\n  const provider: RaAuthProvider = {\n    // React Admin Interface\n    login: (params) => auth.HandleAuthLogin(params),\n    logout: () => auth.HandleAuthLogout(),\n    checkAuth: () => auth.HandleAuthCheck(),\n    checkError: (error) => auth.HandleAuthError(error),\n    getPermissions: () => auth.HandleGetPermissions(),\n    getIdentity: () => auth.HandleGetIdentity(),\n    // Custom Functions\n    getAuthUser: () => auth.getUserLogin(),\n    getJWTAuthTime: () => auth.HandleGetJWTAuthTime(),\n    getJWTExpirationTime: () => auth.HandleGetJWTExpirationTime(),\n    getJWTSignInProvider: () => auth.HandleGetJWTSignInProvider(),\n    getJWTClaims: () => auth.HandleGetPermissions(),\n    getJWTToken: () => auth.HandleGetJWTToken(),\n  };\n  return provider;\n}\n\nfunction VerifyAuthProviderArgs(\n  firebaseConfig: {},\n  options: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n}\n","// From firebase SDK\n\nimport { logError } from \"./logger\";\n\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusTxt(status: number): 'ok' | 'unauthenticated' {\n  // Make sure any successful status is OK.\n  if (status >= 200 && status < 300) {\n    return 'ok';\n  }\n  switch (status) {\n    case 401: // 'unauthenticated'\n    case 403: // 'permission-denied'\n      return 'unauthenticated';\n\n    case 0: // 'internal'\n    case 400: // 'invalid-argument'\n    case 404: // 'not-found'\n    case 409: // 'aborted'\n    case 429: // 'resource-exhausted'\n    case 499: // 'cancelled'\n    case 500: // 'internal'\n    case 501: // 'unimplemented'\n    case 503: // 'unavailable'\n    case 504: // 'deadline-exceeded'\n    default:\n      // ignore\n      return 'ok';\n  }\n}\n\n// From firebase SDK\n// tslint:disable-next-line:max-line-length\n// - https://github.com/firebase/firebase-js-sdk/blob/9f109f85ad0d99f6c13e68dcb549a0b852e35a2a/packages/functions/src/api/error.ts\nexport function retrieveStatusCode(statusTxt: string): number {\n  // Make sure any successful status is OK.\n  const regexResult = /\\[code\\=([\\w-]*)/g.exec(statusTxt);\n  const status = Array.isArray(regexResult) && regexResult[1];\n  if (!status) {\n    logError('unknown StatusCode ', {statusTxt});\n  }\n  switch (status) {\n    case 'unauthenticated':\n      return 401;\n    case 'permission-denied':\n      return 403;\n    case 'internal':\n      return 0;\n    case 'invalid-argument':\n      return 400;\n    case 'not-found':\n      return 404;\n    case 'aborted':\n      return 409;\n    case 'resource-exhausted':\n      return 429;\n    case 'cancelled':\n      return 499;\n    case 'internal':\n      return 500;\n    case 'unimplemented':\n      return 501;\n    case 'unavailable':\n      return 503;\n    case 'deadline-exceeded':\n      return 504;\n    default:\n      return 200;\n  }\n}\n","import {\n  getAbsolutePath,\n  log,\n  logger,\n  retrieveStatusCode,\n  logError,\n  MakeFirestoreLogger,\n} from \"../misc\";\nimport * as ra from \"../misc/react-admin-models\";\nimport { RAFirebaseOptions } from \"./options\";\nimport { FirebaseWrapper } from \"./database/firebase/FirebaseWrapper\";\nimport { FireApp } from \"./database/firebase/IFirebaseWrapper\";\nimport { FireClient } from \"./database/FireClient\";\nimport { GetList, GetMany, GetManyReference, GetOne } from \"./queries\";\nimport { Create, Delete, DeleteMany, Update, UpdateMany } from \"./commands\";\n\nexport interface IDataProvider extends ra.DataProvider {\n  app: FireApp;\n}\n\nexport function DataProvider(\n  firebaseConfig: {},\n  optionsInput?: RAFirebaseOptions\n): IDataProvider {\n  const options = optionsInput || {};\n  verifyDataProviderArgs(firebaseConfig, options);\n\n  const flogger = MakeFirestoreLogger(options);\n  logger.SetEnabled(!!options?.logging);\n  flogger.SetEnabled(!!options?.firestoreCostsLogger?.enabled);\n  flogger.ResetCount(!options?.firestoreCostsLogger?.persistCount);\n  log('Creating FirebaseDataProvider', {\n    firebaseConfig,\n    options\n  });\n\n  const fireWrapper = new FirebaseWrapper();\n  fireWrapper.init(firebaseConfig, optionsInput);\n\n  async function run<T>(cb: () => Promise<T>) {\n    let res: any;\n    try {\n      res = await cb();\n      return res;\n    } catch (error) {\n      const errorMsg = error.toString();\n      const code = retrieveStatusCode(errorMsg);\n      const errorObj = { status: code, message: errorMsg, json: res };\n      logError(\"DataProvider:\", error, { errorMsg, code, errorObj });\n      throw errorObj;\n    }\n  }\n  const client = new FireClient(fireWrapper, options, flogger);\n\n  const newProviderApi: IDataProvider = {\n    app: fireWrapper.GetApp(),\n    getList<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetListParams\n    ): Promise<ra.GetListResult<RecordType>> {\n      return run(() => GetList<RecordType>(resource, params, client));\n    },\n    getOne<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetOneParams\n    ): Promise<ra.GetOneResult<RecordType>> {\n      return run(() => GetOne<RecordType>(resource, params, client));\n    },\n    getMany<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyParams\n    ): Promise<ra.GetManyResult<RecordType>> {\n      return run(() => GetMany<RecordType>(resource, params, client));\n    },\n    getManyReference<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.GetManyReferenceParams\n    ): Promise<ra.GetManyReferenceResult<RecordType>> {\n      return run(() =>\n        GetManyReference<RecordType>(resource, params, client)\n      );\n    },\n    update<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.UpdateParams\n    ): Promise<ra.UpdateResult<RecordType>> {\n      return run(() => Update<RecordType>(resource, params, client));\n    },\n    updateMany(\n      resource: string,\n      params: ra.UpdateManyParams\n    ): Promise<ra.UpdateManyResult> {\n      return run(() => UpdateMany(resource, params, client));\n    },\n    create<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.CreateParams\n    ): Promise<ra.CreateResult<RecordType>> {\n      return run(() => Create<RecordType>(resource, params, client));\n    },\n    delete<RecordType extends ra.Record = ra.Record>(\n      resource: string,\n      params: ra.DeleteParams\n    ): Promise<ra.DeleteResult<RecordType>> {\n      return run(() => Delete(resource, params, client));\n    },\n    deleteMany(\n      resource: string,\n      params: ra.DeleteManyParams\n    ): Promise<ra.DeleteManyResult> {\n      return run(() => DeleteMany(resource, params, client));\n    },\n  };\n\n  return newProviderApi;\n}\n\nfunction verifyDataProviderArgs(\n  firebaseConfig: {},\n  options?: RAFirebaseOptions\n) {\n  const hasNoApp = !options || !options.app;\n  const hasNoConfig = !firebaseConfig;\n  if (hasNoConfig && hasNoApp) {\n    throw new Error(\n      'Please pass the Firebase firebaseConfig object or options.app to the FirebaseAuthProvider'\n    );\n  }\n  if (options && options.rootRef) {\n    // Will throw error if rootRef doesn't point to a document\n    getAbsolutePath(options.rootRef, 'test');\n  }\n}\n","import { FireClient } from '../database/FireClient';\nimport { FirebaseLazyLoadingClient } from '../lazy-loading/FirebaseLazyLoadingClient';\nimport {\n  filterArray,\n  log,\n  recursivelyMapStorageUrls,\n  sortArray,\n} from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetList<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetListParams,\n  client: FireClient\n): Promise<ra.GetListResult<T>> {\n  log('GetList', { resourceName, params });\n  const { rm, fireWrapper, options } = client;\n\n  if (options?.lazyLoading?.enabled) {\n    const lazyClient = new FirebaseLazyLoadingClient(\n      options,\n      rm,\n      client\n    );\n    return lazyClient.apiGetList<T>(resourceName, params);\n  }\n\n  const filterSafe = params.filter || {};\n\n  const collectionQuery = filterSafe.collectionQuery;\n  delete filterSafe.collectionQuery;\n\n  const r = await rm.TryGetResource(resourceName, 'REFRESH', collectionQuery);\n  const data = r.list;\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === 'ASC') {\n      sortArray(data, field, 'asc');\n    } else {\n      sortArray(data, field, 'desc');\n    }\n  }\n  let softDeleted = data;\n  if (options.softDelete && !Object.keys(filterSafe).includes('deleted')) {\n    softDeleted = data.filter((doc) => !doc.deleted);\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = filteredData.slice(pageStart, pageEnd) as T[];\n  const total = filteredData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      dataPage.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n      total,\n    };\n  }\n\n  return {\n    data: dataPage,\n    total,\n  };\n}\n","import { FireClient } from '../database/FireClient';\nimport { log, recursivelyMapStorageUrls } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetOne<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetOneParams,\n  client: FireClient\n): Promise<ra.GetOneResult<T>> {\n  log('GetOne', { resourceName, params });\n  const { rm, fireWrapper } = client;\n  try {\n    const id = params.id + '';\n    const dataSingle = await rm.GetSingleDoc(resourceName, id);\n    client.flogger.logDocument(1)();\n    const data = await recursivelyMapStorageUrls(fireWrapper, dataSingle);\n    return { data: data };\n  } catch (error) {\n    throw new Error(\n      'Error getting id: ' + params.id + ' from collection: ' + resourceName\n    );\n  }\n}\n","import { FireClient } from '../database/FireClient';\nimport { log, recursivelyMapStorageUrls } from '../../misc';\nimport * as ra from '../../misc/react-admin-models';\n\nexport async function GetMany<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyParams,\n  client: FireClient\n): Promise<ra.GetManyResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log('GetMany', { resourceName, resource: r, params });\n  const ids = params.ids;\n  const matchDocSnaps = await Promise.all(\n    ids.map((id) => r.collection.doc(id + '').get())\n  );\n  client.flogger.logDocument(ids.length)();\n  const matches = matchDocSnaps.map((snap) => {\n    return { ...snap.data(), id: snap.id } as T;\n  });\n  const permittedData = options.softDelete\n    ? matches.filter((row) => !row['deleted'])\n    : matches;\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) => recursivelyMapStorageUrls(fireWrapper, doc))\n    );\n    return {\n      data,\n    };\n  }\n\n  return {\n    data: permittedData,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { filterArray, log, recursivelyMapStorageUrls, sortArray } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function GetManyReference<T extends ra.Record>(\n  resourceName: string,\n  params: ra.GetManyReferenceParams,\n  client: FireClient\n): Promise<ra.GetManyReferenceResult<T>> {\n  const { rm, options, fireWrapper } = client;\n  log(\"GetManyReference\", { resourceName, params });\n  const filterSafe = params.filter || {};\n  const collectionQuery = filterSafe.collectionQuery;\n  const r = await rm.TryGetResource(\n    resourceName,\n    \"REFRESH\",\n    collectionQuery\n  );\n  delete filterSafe.collectionQuery;\n  log(\"apiGetManyReference\", { resourceName, resource: r, params });\n  const data = r.list;\n  const targetField = params.target;\n  const targetValue = params.id;\n  let softDeleted = data;\n  if (options.softDelete) {\n    softDeleted = data.filter(doc => !doc['deleted'])\n  }\n  const filteredData = filterArray(softDeleted, filterSafe);\n  const targetIdFilter = {} as any;\n  targetIdFilter[targetField] = targetValue;\n  const permittedData = filterArray(filteredData, targetIdFilter);\n  if (params.sort != null) {\n    const { field, order } = params.sort;\n    if (order === \"ASC\") {\n      sortArray(permittedData, field, \"asc\");\n    } else {\n      sortArray(permittedData, field, \"desc\");\n    }\n  }\n  const pageStart = (params.pagination.page - 1) * params.pagination.perPage;\n  const pageEnd = pageStart + params.pagination.perPage;\n  const dataPage = permittedData.slice(pageStart, pageEnd) as T[];\n  const total = permittedData.length;\n\n  if (options.relativeFilePaths) {\n    const data = await Promise.all(\n      permittedData.map((doc) =>\n        recursivelyMapStorageUrls(fireWrapper, doc)\n      )\n    );\n    return { data, total };\n  }\n\n  return { data: dataPage, total };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Update<T extends ra.Record>(\n  resourceName: string,\n  params: ra.UpdateParams,\n  client: FireClient\n): Promise<ra.UpdateResult<T>> {\n  const { rm } = client;\n  log(\"Update\", { resourceName, params });\n  const id = params.id + \"\";\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Update\", { resourceName, resource: r, params });\n  const data = await client.parseDataAndUpload(r, id, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, id);\n  await client.addUpdatedByFields(docObj);\n  await r.collection.doc(id).update(docObj);\n  return {\n    data: {\n      ...data,\n      id: id,\n    },\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function UpdateMany(\n  resourceName: string,\n  params: ra.UpdateManyParams,\n  client: FireClient\n): Promise<ra.UpdateManyResult> {\n  const { rm } = client;\n  log(\"UpdateMany\", { resourceName, params });\n  delete params.data.id;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"UpdateMany\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async id => {\n      const idStr = id+'';\n      const data = await client.parseDataAndUpload(r, idStr, params.data);\n      const docObj = { ...data };\n      client.checkRemoveIdField(docObj, idStr);\n      await client.addUpdatedByFields(docObj);\n      await r.collection\n        .doc(idStr)\n        .update(docObj);\n      return {\n        ...data,\n        id: idStr\n      };\n    })\n  );\n  return {\n    data: returnData\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function Create<T extends ra.Record>(\n  resourceName: string,\n  params: ra.CreateParams,\n  client: FireClient\n): Promise<ra.CreateResult<T>> {\n  const { rm, fireWrapper } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"Create\", { resourceName, resource: r, params });\n  const hasOverridenDocId = params.data && params.data.id;\n  log(\"Create\", { hasOverridenDocId });\n  if (hasOverridenDocId) {\n    const overridenId = params.data.id;\n    const exists = (await r.collection.doc(overridenId).get()).exists;\n    if (exists) {\n      throw new Error(\n        `the id:\"${overridenId}\" already exists, please use a unique string if overriding the 'id' field`\n      );\n    }\n    const data = await client.parseDataAndUpload(r, overridenId, params.data);\n    if (!overridenId) {\n      throw new Error(\"id must be a valid string\");\n    }\n    const docObj = { ...data };\n    client.checkRemoveIdField(docObj, overridenId);\n    await client.addCreatedByFields(docObj);\n    await client.addUpdatedByFields(docObj);\n    log(\"Create\", { docObj });\n    await r.collection.doc(overridenId).set(docObj, { merge: false });\n    return {\n      data: {\n        ...data,\n        id: overridenId,\n      },\n    };\n  }\n  const newId = fireWrapper.db().collection(\"collections\").doc().id;\n  const data = await client.parseDataAndUpload(r, newId, params.data);\n  const docObj = { ...data };\n  client.checkRemoveIdField(docObj, newId);\n  await client.addCreatedByFields(docObj);\n  await client.addUpdatedByFields(docObj);\n  await r.collection.doc(newId).set(docObj, { merge: false });\n  return {\n    data: {\n      ...data,\n      id: newId,\n    },\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteSoft } from \"./Delete.Soft\";\n\nexport async function Delete<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm, options } = client;\n  if (options.softDelete) {\n    return DeleteSoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"apiDelete\", { resourceName, resource: r, params });\n  try {\n    const id = params.id + \"\";\n    await r.collection.doc(id).delete();\n  } catch (error) {\n    throw new Error(error);\n  }\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteSoft<T extends ra.Record>(\n  resourceName: string,\n  params: ra.DeleteParams,\n  client: FireClient\n): Promise<ra.DeleteResult<T>> {\n  const { rm } = client;\n  const id = params.id + \"\";\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteSoft\", { resourceName, resource: r, params });\n  const docObj = { deleted: true };\n  await client.addUpdatedByFields(docObj);\n  r.collection\n    .doc(id)\n    .update(docObj)\n    .catch((error) => {\n      logError(\"DeleteSoft error\", { error });\n    });\n  return {\n    data: params.previousData as T,\n  };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\nimport { DeleteManySoft } from \"./DeleteMany.Soft\";\n\ntype DocumentRef = firebase.firestore.DocumentReference<any>;\n\nexport async function DeleteMany(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { options, rm, fireWrapper } = client;\n  if (options.softDelete) {\n    return DeleteManySoft(resourceName, params, client);\n  }\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteMany\", { resourceName, resource: r, params });\n  const returnData: ra.Identifier[] = [];\n  const batch = fireWrapper.db().batch();\n  for (const id of params.ids) {\n    const idStr = id + '';\n    const docToDelete = r.collection.doc(idStr) as DocumentRef;\n    batch.delete(docToDelete);\n    returnData.push(id);\n  }\n  try {\n    await batch.commit();\n  } catch (error) {\n    throw new Error(error)\n  }\n  return { data: returnData };\n}\n","import { FireClient } from \"../database/FireClient\";\nimport { log, logError } from \"../../misc\";\nimport * as ra from \"../../misc/react-admin-models\";\n\nexport async function DeleteManySoft(\n  resourceName: string,\n  params: ra.DeleteManyParams,\n  client: FireClient\n): Promise<ra.DeleteManyResult> {\n  const { rm } = client;\n  const r = await rm.TryGetResource(resourceName);\n  log(\"DeleteManySoft\", { resourceName, resource: r, params });\n  const ids = params.ids;\n  const returnData = await Promise.all(\n    ids.map(async (id) => {\n      const idStr = id + \"\";\n      const docObj = { deleted: true };\n      await client.addUpdatedByFields(docObj);\n      r.collection\n        .doc(idStr)\n        .update(docObj)\n        .catch((error) => {\n          logError(\"apiSoftDeleteMany error\", { error });\n        });\n      return idStr;\n    })\n  );\n  return {\n    data: returnData,\n  };\n}\n"],"names":["parseAllDatesDoc","obj","Object","keys","map","key","recusivelyCheckObjectValue","input","toDate","Array","isArray","value","parseFireStoreDocument","doc","data","id","sortArray","field","dir","sort","a","b","rawA","get","rawB","isAsc","Number","isFinite","basicSort","toLowerCase","Date","aValue","bValue","filterArray","searchFields","isEmpty","searchObjs","fieldName","getSubObjects","searchField","searchValue","tree","leaves","recursivelyWalk","path","hasOwnProperty","objVal","currentPath","push","objectFlatten","getFieldReferences","filter","row","reduce","acc","cur","searchThis","toString","includes","doesRowMatch","LogNoOp","LoggerBase","title","cacheEnabledKey","this","isEnabled","localStorage","getItem","SetEnabled","setItem","removeItem","console","log","bind","warn","error","logger","logError","logWarn","KEY_SINGLE","s","then","pact","result","state","_settle","onRejected","recursivelyMapStorageUrls","fireWrapper","fieldValue","isObject","isFileField","src","startsWith","ref","storage","getDownloadURL","_exit2","i","getAbsolutePath","rootRef","relativePath","Error","rootRefValue","withSlashes","join","split","length","slice","FirebaseWrapper","GetApp","app","init","firebaseConfig","options","optionsSafe","firebase","apps","initializeApp","ObtainFirebaseApp","firestore","db","serverTimestamp","auth","GetUserLogin","Promise","resolve","reject","_this2","onAuthStateChanged","user","OnUserLogout","callBack","isLoggedOut","ResourceManager","flogger","_this","resources","TryGetResource","resourceName","refresh","collectionQuery","TryGetResourcePromise","_this3","RefreshResource","GetResource","resource","_this5","initPath","_this7","_this7$options","lazyLoading","_this7$options$lazyLo","enabled","collection","query","applyQuery","newDocs","list","docs","logDocument","collectionPath","GetSingleDoc","docId","_this9","docSnap","exists","absolutePath","hasBeenInited","pathAbsolute","allResources","getUserIdentifier","associateUsersById","getCurrentUserId","getCurrentUserEmail","email","uid","collRef","FireClient","rm","checkRemoveIdField","dontAddIdFieldToDoc","parseDataAndUpload","r","docPath","uploads","recusivelyParseObjectValue","fieldPath","index","fieldDotsPath","fieldSlashesPath","rawFile","parseDocGetAllUploads","all","u","uploadAndGetLink","useFileNamesInStorage","uploadRes","set","addCreatedByFields","disableMeta","currentUserIdentifier","createAtSelector","renameMetaFields","created_at","casing","metaFieldCasing","GetSelectorsCreateAt","createBySelector","created_by","GetSelectorsCreateBy","AddCreatedByFields","addUpdatedByFields","updateAtSelector","updated_at","GetSelectorsUpdateAt","updateBySelector","updated_by","GetSelectorsUpdateBy","AddUpdatedByFields","useFileName","uuidv4","storagePath","saveFile","task","_this10","put","res","rej","taskResult","relativeFilePaths","storageError","code","callback","v","thenable","getQueryCursor","params","btoa","JSON","stringify","paramsToQuery","defaultParamsToQueryOptions","filtersStepQuery","filters","forEach","where","sortStepQuery","parsedOrder","order","toLocaleLowerCase","orderBy","sortToQuery","pagination","page","perPage","queryCursor","startAfter","limit","queryBase","currentPage","newQuery","startAt","lastQueryCursor","snapshots","docsLength","currentPageParams","findLastQueryCursor","paginationToQuery","getFullParamsForQuery","reactAdminParams","softdeleteEnabled","deleted","array","FirebaseLazyLoadingClient","client","apiGetList","tryGetResource","softDelete","resultsCount","message","total","nextPageCursor","allCursorsKey","localCursorKeys","newCursors","parse","concat","setQueryCursor","getNextPageParams","checkIfOnLastPage","isOnLastPage","parsedData","apiGetManyReference","_this4","filterWithTarget","target","nextElementSnapshot","empty","clearQueryCursors","cursor","AuthClient","optionsInput","persistence","setPersistence","persistenceInput","persistenceResolved","Auth","Persistence","LOCAL","NONE","SESSION","HandleAuthLogin","username","password","signInWithEmailAndPassword","getUserLogin","HandleAuthLogout","signOut","HandleAuthError","errorHttp","status","retrieveStatusTxt","HandleAuthCheck","currentUser","unsubscribe","HandleGetPermissions","getIdTokenResult","token","claims","e","HandleGetIdentity","displayName","photoURL","fullName","avatar","HandleGetJWTAuthTime","_this11","authTime","HandleGetJWTExpirationTime","_this13","expirationTime","HandleGetJWTSignInProvider","_this15","signInProvider","HandleGetJWTIssuedAtTime","_this17","issuedAtTime","HandleGetJWTToken","_this19","VerifyAuthProviderArgs","logging","login","logout","checkAuth","checkError","getPermissions","getIdentity","getAuthUser","getJWTAuthTime","getJWTExpirationTime","getJWTSignInProvider","getJWTClaims","getJWTToken","run","cb","errorMsg","statusTxt","regexResult","exec","retrieveStatusCode","errorObj","json","verifyDataProviderArgs","ResetCount","shouldReset","docCount","_options$lazyLoading","count","incrementBy","currentCountRaw","incremented","parseInt","incrementRead","MakeFirestoreLogger","firestoreCostsLogger","_options$firestoreCos","_options$firestoreCos2","persistCount","getList","lazyClient","filterSafe","dataPage","softDeleted","filteredData","pageStart","GetList","getOne","dataSingle","GetOne","getMany","ids","matchDocSnaps","permittedData","matches","snap","GetMany","getManyReference","targetField","targetValue","targetIdFilter","GetManyReference","update","docObj","Update","updateMany","idStr","returnData","UpdateMany","create","newId","merge","hasOverridenDocId","overridenId","_r$collection$doc$get","Create","previousData","DeleteSoft","Delete","deleteMany","DeleteManySoft","batch","docToDelete","commit","DeleteMany"],"mappings":"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"}